---
title: CMU15-213《深入理解计算机系统》观看笔记
description: 时间轴记录
#date: 2020-01-01
#updated: 2020-01-01
categories:
- CSAPP
tags:
- CSAPP
---



&emsp;&emsp;1-10,12-13是复制别人的b站评论，其它是自己写

# Lecture01

观看记录📝

05:23 课程主题Abstraction is Good But Don’t Forget The Reality
07:22 课程目标 1.让你更有效率；2.给你十分有用的工具；
07:35 课程内容和课程意义

课程内容
几个关于系统的例子
09:13 #1 Ints和Floats (gdb)
17:03 #2 Assembly汇编语言
18:37 #3 内存的重要性
25:23 #4 底层优化
28:59 #5 I/O的重要性和网络

课程意义
29:07 课程意义部分

课程观点
30:31 builder角度和程序员角度

34:44 关于北大旁书店的笑话 还蛮好笑的
38:49 学术诚信:高层次可以，低层次不行
46:14 学习策略，每次阅读每章三次，然后做练习题
51:16 课程邮箱，FAQ

1:02:01 六个实验的介绍
1:02:08 数据实验
1:03:24 炸弹实验
1:06:09 攻击实验
1:07:11 缓存实验
1:09:27 Shell实验
1:09:55 malloc实验
1:12:20 proxy实验

# Lecture02

观看记录📝

02:13 bit比特
03:33 二进制的数字表示
04:49 编码一个字节以及16进制表示
06:39 C中数据类型的长度
08:50 布尔代数和操作符
11:10 对向量操作的布尔代数
12:07 使用布尔代数表示和操作集合
14:30 逻辑操作和位操作的对比
18:44 移位操作
21:09 数字表示
26:37 数字表示的范围
有符号数和无符号数
35:58 位表示到两者的转换
37:16 有符号数和无符号数的相互转换
41:46 C中有符号数和无符号数
55:57 有符号数和无符号数的转换
57:53 关于无符号数的两个问题
1:01:03 有符号数的扩展
1:06:04 扩展和截断的总结[加油武汉]

# Lecture03

观看记录📝
位表示
位级别的操作
整数
- 表示：无符号和有符号
- 约定和转换
- 扩展和截断
- 加法，减法，乘法，移位
内存，指针，字符串的表示
总结

02:32 无符号数的加法
06:19 无符号运算加法的可视化
06:42 补码的加法
13:42 补码加法的可视化
15:02 无符号数的乘法
17:20 C中有符号数的乘法
24:33 2的指数幂乘法和左移等价
26:32 2的指数幂除法和右移等价
28:48 逻辑移位和算术移位应用
36:03 不要使用无符号数的原因
39:03 如果使用无符号数的规范
44:22 使用无符号数的原因44:56 内存，指针，字符串的表示
48:00 内存的结构梳理
49:39 机器的字长
53:14 面向字节的内存结构
【这里关于内存，需要推荐一下另一门课《十分钟计算机科学-内存部分》，看完对这部分会有更好的理解】
57:05 小端序和大端序
1:01:19 数据表示的例子
1:08:38 字符串部分「很简单地略过」
1:09:58 整数问题的小测验

# Lecture04

浮点数 观看记录📝
2:44 二进制分数的表示，浮点数“浮点”的来源
08:07 IEEE floating point
08:25 浮点数的表示
10:56 规格化的值
20:20 解释exp阶码部分，这个地方其实解释有误；其实展示的是阶码整体的范围，包括非规格化时；
23:53 非规格化的值
26:14 特殊值
28:29 浮点数编码的可视化
29:49 浮点数编码的简单例子
39:56 浮点数编码的属性
41:34 浮点数运算的基本思想(运算后舍入)
44:25 舍入的方法
51:33 二进制的舍入
54:56 浮点数的乘法
56:30 浮点数的加法
56:54 浮点数加法和乘法的数学性质
62:59 C中的浮点数
67:20 浮点数的练习题

# Lecture05 机器级编程(基础)

观看记录📝
01:49 课程学习方法
03:54 intel处理器的历史和架构
06:25 RISC和CISC的历史
08:12 英特尔架构的里程碑
12:51 Corei7的架构
14:28 竞争对手AMD的历史
15:35 64位的转变
17:49 ARM处理器
19:35 C,assembly,machine code
22:02 Machine/Assembly code的视角
25:19 将C代码翻译为目标代码的过程
30:12 C代码到汇编代码的例子，-O优化
34:36 汇编代码的特性
34:48 数据类型
35:56 操作
36:54 sumstore的例子
39:14 Disassembling反汇编器：objdump和gdb
47:50 Assembly基础:寄存器，操作数，move指令
48:12 X86-64寄存器
53:38 move指令
56:59 Simple Memory Addressing Modes
58:09 简单寻址的例子
56:59 Complex Memory Addressing Modes
65:12 寻址的例子
66:15 算术和逻辑操作
66:40 lea指令
73:02 总结

# Lecture06 机器级编程(控制)

观看记录📝
04:00 处理器的状态（关于当前运行程序的信息，rax,rsp,rip）
05:51 条件码
07:55 比较指令(cmp,test)
11:46 读状态码(setx,)
20:14 状态分支
20:36 跳转指令(这里还提及了+=的来源)
26:54 C中goto语句(尽量还是不要用，不清晰)
29:05 通用条件表达的转换(使用分支)
31:41 条件移动
35:48 条件移动的例子
36:49 条件移动不适合的情况
38:27 循环
(总的来说就是把各种形式的循环归并成一种形式)
38:29 "Do while"的例子(C语言)
40:44 "Do while"的例子(编译结果)
41:05 通用的"Do while"的Goto版本
41:21 通用的"While"的Goto版本(1)
44:07 "While"的例子
45:34 通用的"While"的Goto版本(2)
46:26 "For Loop"的形式
47:38 "For" -> "While Loop"的转换
50:10 Switch语句
51:01 Switch语句的例子
53:44 Switch的解释(不是if-else的组合！！！超酷的)
1:12:31 总结

# Lecture07 机器级编程(过程)

观看记录📝
Procedures

Stack Structure
Calling Conventions
Passing control
Passing data
Managing local data
Illustration of Recursion
2:45 ABI

3:50 Procedures的机制
7:34 X86-64Stack
ABI中调用的约定

14:38 过程中的控制
15:32 过程中的控制(例子)
21:43 过程中的数据(参数传递)
23:06 过程中的数据(例子)
26:19 过程中的局部变量管理
26:22 栈帧
31:15 一个具体的例子
34:42 X86-64/Linux栈帧的结构
39:06 Calling incr的例子
过程调用中寄存器的使用
46:29 Register保存的约定
49:38 不同寄存器的用途
51:17 被调用者保存寄存器的使用示例及其工作原理
递归部分的解释
54:31 递归的例子
1:03:40 递归部分的总结

# Lecture08 机器级编程(数据)

观看记录📝
数组
04:16 数组声明
05:14 数组访问
14:38 数组的例子
21:49 数组和指针的不同(C语言部分，可看书)
39:47 嵌套数组
45:32 嵌套数组的访问
51:04 多层数组的元素访问
54:58 N*N的矩阵
56:41 16*16数组访问的例子
结构
59:24 结构体的表示
1:00:16 指向结构体成员的指针
1:05:34 结构体和对齐的概念
1:07:03 对齐的原则
1:11:15 节省内存
浮点数
1:13:00 浮点数的历史
1:14:44 SSE3编程
1:16:01 Scalar和SIMD(真的好感动，实习时用过)
1:17:13 FP运算的知识
其实这里应该提及多个浮点数一起运算的加速效果

# Lecture09 机器级编程(高级专题)

观看记录📝
内存布局
2:14 最大寻址大小的解释(47位)（limit）
10:30 内存布局的解释(stack,heap,data,text/shared lib)
12:07 内存分配的例子
缓冲区溢出
17:54 缓冲区问题介绍
19:39 String库的缓冲区例子-gets,strcpy,strcat
23:26 缓冲区问题例子
32:15 缓冲区问题(缓存区溢出攻击例子)
33:31 代码注入攻击解释(很有意思)
36:47 当你替换代码是，如何确定注入的代码提供了准确的地址
38:09 Buffer overflows的历史
42:30 蠕虫和病毒的区别
43:09 避免缓冲区攻击的手段
43:24 避免程序中的缓冲区溢出
45:28 系统级别的防御:ASLR,权限，canary(啊啊啊啊啊,canary我遇到过)
1:03:51 关于这三种手段的老师的评价
1:10:59 attack lab讲解
1:12:59 联合体
1:13:40 联合体内存分布
1:15:40 字节顺序的问题

# Lecture10 程序优化

观看记录📝
01:10 整体的程序优化手段介绍
03:08 性能的两条人间真实:常数因子也很重要;必须了解系统知识才能优化性能
04:32 关于Compiler(编译器)的一些介绍
06:32 代码移动(Code Move)，先计算需要计算的值，然后在之后一直使用这个值
08:45 计算量减少(Reduction in Strength),将乘法转化为加法
10:07 共享通用表达(Share Common SubExpressions),通过抽取子表达式，将其提前转化为共享变量的方式减少计算量
13:00 优化中的障碍
13:10 障碍1，过程调用
18:08 为什么编译器无法优化这种过程调用错误,变量在变化，无法确定函数体内容
21:02 障碍2，内存别名导致，重复对内存地址进行读取的问题;
22:57 障碍2是由于内存别名的存在，导致程序无法确定两个内存是否完全无关，所以需要重复读取;
32:11 无序执行(乱序执行)，利用指令级别的并行
32:32 程序加速的例子
35:13 CPE指标的引入
38:30 程序加速，改进例子的极少
40:35 指令级并行的基本思想
44:26 超标量计算机简介
45:03 流水线技术，及其如何将计算分解为一系列不同的阶段
48:40 HasWell，不同阶段对应的时钟周期
51:00 计算机中，顺序依赖概念的解释
51:30 循环展开，对性能提高的效果展示
52:50 循环展开对于不同运算的性能提高效果
53:29 运算顺序改变，对于不同运算的性能提升效果
61:20 Avx2指令加速
66:46 条件预测，提前加载指令进行加速
72:30 获得高性能程序的一些关键点

# Lecture11 The Memory Hierarchy

02:45 SRAM和DRAM对比
04:50 Nonvalatile Memories(非易失性存储器)ROM，PROM，EPROM，EEPROM
07:17 bus总线，连接cpu芯片和主存
09:06 movq指令在总线上运行过程
12:05 机械硬盘结构
13:32 盘片，磁道，扇区
14:15 主轴多个盘片对齐
14:40 磁盘容量
15:40 磁盘容量影响因素 记录密度，磁道密度，面密度
16:20 面密度以前里外一样，现在不一样
18:10 计算磁盘容量
18:35 磁盘操作，旋转，磁臂移动
20:33 磁盘读操作
21:35 访问时间，寻道时间，旋转时间（平均是一圈的一半），传送时间
23:32 用真正的数字计算
25:33 逻辑磁盘 备用柱面
27:00 IO总线，现代PCI总线
29:18 CPU访问磁盘发生的步骤
30:00 DMA（直接内存访问）传送，磁盘传到内存不经过CPU
31:57 固态硬盘 闪存翻译层 块 页
35:05 性能特点 读写速度，顺序读写，随机读写
36:48 与旋转磁盘对比，用途
37:40 85～15年磁盘，DRAM，CPU速度发展
39:15 03年时钟频率很难加了，intel出了800w的CPU
41:00 CPU开始增加内核，05年出现双核
44:10 局部性：弥合CPU和内存之间差距的关键
45:27 时间局部性和空间局部性
46:10 例子
49:00 另一个例子，双重循环a[i][j]
52:56 三重循环应该怎么放顺序
55:08 存储器层次结构 L0～L6
58:15 Caches（缓存），举了个例子，去上学，书包就是家里屋子的缓存
1:01:49 缓存一般的工作方式(下节课讲细节)，内存分块
1:04:03 复制整个块
1:05:25 缓存命中
1:05:57 缓存不命中，CPU等待高速缓存从内存中取出块
1:06:35 不命中的种类。冷不命中也叫强制不命中，缓存是空的。
1:07:23 容量不命中，因为缓存大小有限，如果要用到比高速缓存大的数据，块就不够用了，工作集的概念
1:09:60 冲突未命中。缓存的实现方式，最简单的模型就是第i块只能放在(i mod 缓存大小_单位为块)处，要用到mod相同的就容易覆盖
1:11:37 各层各种形式缓存详细表格(书上P425)。依次是Register, TLB(翻译后备缓存), L1, L2, Virtual Memory, Buffer cache, Disk cache, Network buffer cache，Brower cache, Web cache

# Lecture12 Cache Memory

观看记录📝
01:09 内存的层级结构
01:54 Cache的概念
04:42 Cache的组织结构
07:30 Cache读
07:30 Cache的寻址方式
10:38 Direct Mapped Cache(E = 1)
20:58 E-way Set Associative Cache(E = 2)
35:38 Cache写
write hit
36:11 wrtie through and write back(脏位)
write miss
37:47 write-allocate and No-write-allocate
39:40 英特尔i7的cache架构
42:42 Cache性能的度量:MIss Rate, Hit Time, Miss Penalty
44:53 关于Cache数量度量的例子
46:58 写出缓存友好的代码
50:57 Memory Mountain
53:48 Memory Mountain Test代码
56:30 Memory Mountain可视化代码
59:14 Ridges of temporal locality时间局部性的山脊
1:03:53 重新排列循环
1:04:01 Matrix Multiplication例子
1:05:13 Miss Rate分析
1:08:05 Matrix Multiplication的总结
1:10:31 分块技术
1:14:41 分块技术的Cache Miss分析
1:16:14 Blocking的效果分析

# Lecture13 链接

观看记录📝
01:51 静态链接的过程
03:40 为什么要用链接：模块化，效率(编译)
05:20 连接器的作用
05:25 符号解析
07:20 重定位
09:20 三种目标文件的分类
09:25 .o可重定位目标模块
09:50 .out可执行文件
10:15 ,so共享目标文件
10:32 目标模块ELF标准
10:58 目标文件的格式:header,segment header table, .text section, .rodata section,.data section,.bss section, .symtab section, .rel .txt section,.rel .data section,.debug section, section header
15:13 链接器的符号分类，global symbols, external symbols, local symbols
19:30 局部非静态变量 vs 局部静态变量
21:30 链接器如何解决重复符号定义问题？强符号，弱符号;
32:04 避免全局变量的原因
36:00 重定位入口
44:15 加载可执行的目标文件
48:30 打包常用的函数
51:06 静态链接库
55:51 静态库链接的过程
56:13 使用静态库的过程
60:02 共享链接库
62:52 动态链接的加载过程
67:17 运行时的动态链接

杂项
53:13 常用库

示例
24:12 链接错误示例
sum
01:04 C程序示例
18:34 符号解析的过程
32:49 重定位的过程
41:26 重定位后的text部分
案例学习
70:24 库打桩

# Lecture14 异常控制流 异常和进程

02:41 异常控制流会在什么地方存在
05:04 异常的定义，三种情况
07:15 异常表
07:46 异常的分类方法，同步异步。异步异常，中断。
10:20 同步异常，陷阱和系统调用
10:54 故障，页缺失，保护故障
13:03 终止
13:33 Linux/x86-64 常用的系统调用
14:01 syscall，open 
15:54 故障的例子，页缺失，从磁盘到内存
16:58 故障的例子，无效内存引用
18:22 进程的定义
19:14 进程的两个抽象。第一个，独占cpu和寄存器。第二个，拥有自己的地址空间
21:02 top指令看进程
21:27 多进程管理共享，上下文切换是地址空间和寄存器的变化
23:40 逻辑控制流
24:50 并发
26:34 上下文切换的过程，用户模式和内核模式
28:19 系统调用错误处理
30:55 错误报告功能，unix_error
31:38 错误处理包装函数，Fork
32:43 进程控制函数，getpid，getppid
33:11 进程的三种状态，运行，停止，终止
34:18 终止进程，exit
35:33 fork创建子进程，返回两次
37:30 fork的例子
40:03 进程图，捕捉调用fork时发生的情况。顶点是语句的执行，边对应变量
41:30 进程图例子
44:10 多个连续fork例子
48:15 回收子进程
49:00 僵尸进程
49:35 系统安排init进程回收孤儿进程
51:00 一个僵尸现象的例子
52:41 另一个例子，父进程结束子进程没结束
54:14 wait用来与子进程同步并回收它们
55:18 wait工作原理的简单示例
57:35 复杂的例子，waitpid函数
59:59 execve运行不同的程序
1:03:10 新程序开始时的栈帧结构
1:05:56 execve的例子，用途
1:10:37 总结。异常，进程，fork，exit，wait，waitpid，execve

# Lecture15 信号和非本地跳转

00:52 linux进程体系，init创建守护进程Daemon，login shell
02:40 shell，bash
03:16 一个简单shell的main例程
04:17 eval求值
08:45 简单shell例程的问题，内存泄漏
08:55 异常控制流解决问题
09:29 信号的定义，Linux常见信号
13:20 信号的概念：发送信号
15:08 信号的概念：接受信号。三种反应
17:20 信号的概念：挂起和阻塞的信号
20:10 发送信号，进程组
21:44 kill的例子，kill -9,id前加横杠的意思
24:12 键盘发送信号，ctrl+c发送sigint，默认行为终止进程，ctrl+z发送sigtstp，默认行为挂起进程
24:55 ctrl+c和ctrl+z例子，ps命令，fg命令
26:10 系统调用kill发送信号
27:20 进程接受信号
28:33 pnb
30:02 信号的默认行为
30:24 使用signal函数的系统调用修改默认行为
32:25 安装处理程序的例子
33:59 信号处理程序看作并发流
38:00 信号处理程序被其它信号处理程序中断
39:01 阻塞和接触阻塞信号
40:10 用sigprocmasks函数阻塞和解除阻塞信号
42:13 安全的信号处理程序
44:32 编写安全程序的经验参考，6条经验
49:28 异步信号安全，Linux安全的系统级函数
53:08 作者开发的安全的I/O包
54:15 例子fork14
59:38 可移植信号处理，书上P541
63:10 作业列表的例子同步错误 书上P542
67:30 消除竞争的一种方法，书上P543
70:18 显式地等待信号
76:05 sigsuspend

# Lecture16 系统级I/O

02:25 这节课的主要内容
03:52 Unix文件，I/O设备，套接字
05:51 文件的另一种属性，文件位置
07:33 文件种类，今天讲普通文件，目录，套接字。
09:34 普通文件。文本文件换行，二进制文件
13:11 目录，层次结构，路径
14:22 打开文件，open函数，append从末尾打开，打开操作返回文件描述符,limit命令
18:00 返回值，系统调用时检查返回值。打开操作返回有符号返回值，负数表示打开失败
19:35 进程的三个文件描述符，标准输入输出错误，分别对应0 1 2
20:18 close函数关闭文件，遇到错误的情况
21:57 read函数读文件，还需要缓冲区指针和长度，返回0,正数，负数的情况
24:50 write写文件，参数和读类似，
25:48 Read，Write简单例子，这个例子系统级调用开销太大
29:00 演示，strace命令检测出程序运行时的系统调用
31:05 不足值的情况
35:20 作者写的RIO软件包，封装了低级I/O，自动处理不足值
38:13 rio_readn函数
40:47 带缓冲的I/O，rio_readinitb。 
43:20 读缓冲区的格式
44:04 用RIO函数边读边写的例子
46:06 文件元数据
47:06 stat查看文件系统的目录结构
48:42 文件信息如何在程序中表示
51:33 操作系统维护的与程序中文件相关的内部数据结构，考试难点
52:15 描述符表，打开文件表，vnode表
59:07 dup2函数复制描述符表项覆盖，用来做重定向
62:48 C语言标准I/O 带缓冲
65:12 3种I/O。设计RIO的原因，用于网络连接
66:27 每种I/O优缺点
68:53 推荐两本书
70:16 一个文件描述符的例子

# Lecture17 虚拟内存概念

00:21 一个物理寻址的系统
04:09 一个虚拟寻址的系统
05:23 地址空间。线性，虚拟，物理
06:40 为什么要实现虚拟内存，三个原因
09:04 虚拟内存作为缓存工具，磁盘上的虚拟页映射到DRAM中的物理页
11:40 DRAM缓存的组织结构
15:25 页表
17:30 页命中
19:20 处理缺页（DRAM缓存不命中）
20:53 分配页面，malloc函数调用sbrk函数
22:02 虚拟内存工作得很好，因为局部性
24:00 虚拟内存作为内存管理的工具，每个进程有独立的页表
29:18 简化链接和加载
32:49 虚拟内存作为保护内存的工具，48个有效位，高位都是1的地址是内核中的代码和数据，都是0的地址是给用户代码保留的。x86-64新出的EXEC位防止代码注入攻击
36:12 地址翻译 
37:36 使用页表进行地址转换的原理
41:59 地址翻译页面命中
43:01 地址翻译缺页
44:29 结合高速缓存和虚拟内存
48:03 利用MMU中关于PTE的小缓存TLB（翻译后备缓冲器）加速地址翻译
50:10 TLB命中，TLB不命中
51:34 多级页表
53:33 一个二级页表层次结构
55:30 使用k级页表的地址翻译，k个VPN
57:34 问答直到结束

# Lecture18 虚拟内存系统

00:19 简单的内存系统的例子，和书上P574一样
10:54 另一个例子
17:41 虚拟内存在Core i7/Linux下如何工作
24:58 Core i7端到端的地址翻译
28:48 Intel系统页表条目的结构，第一二三级
31:38 第四级页表条目格式
33:25 Core i7页表翻译
36:11 加速访问L1高速缓存
38:36 Liunx虚拟内存系统。内核产生的也是虚拟地址
44:12 Linux虚拟内存区域
46:38 缺页异常处理
50:53 内存映射 
53:40 再看共享对象
56:22 私有写时复制对象
60:49 fork函数，内核只拷贝所有内核数据结构，mm_struct, area_struct和页表。将两个进程的每个页面都标记为只读，每个区域结构都标记为私有写时复制
65:13 execve系统调用。删除当前进程的所有area_struct和页表，为新区域创建新的
71:34 mmap函数用户级内存映射
75:34 mmap的例子

# Lecture19 动态内存分配 基础概念

00:48 本周内容主题：储存器分配，其工作原理，如何使用它们管理虚拟内存
01:05 动态内存分配器，堆
01:56 块被分配和释放，显式分配器malloc和free，隐式分配器使用垃圾回收（Java等）
03:37 malloc，free，calloc初始化分配块为0,realloc调整之前malloc块的大小，sbrk增长和缩小堆
05:40 malloc例子
07:17 今天实现malloc和free等功能，简化假设，内存地址不按字节，按word，假设word是4个字节（int的大小）
08:38 malloc，free分配释放块的例子
10:02 分配器的要求和目标各种约束
12:24 速度和内存效率指标，吞吐量。在malloc和free序列最大化吞吐量和使内存利用率尽可能高
14:01 使内存利用率尽可能高，衡量使用堆的效率。有效载荷/堆的大小
17:24 碎片。内部碎片。
18:58 外部碎片。堆中有足够内存但没有足够大的空闲块
21:36 实现问题。free怎么知道块的大小？怎样追踪空闲块？如何处理剩余空间？如何选择空闲块？如何处理刚刚被释放的块？
23:09 知道要释放多少。块头部编码了块大小
24:15 追踪空闲块。隐式空闲列表，空闲块通过头部的隐含字段连接，分配器可以遍历。
29:00 构建隐式空闲列表。
31:51 需要块的大小和分配状态，不需要两个word，利用块需要边界对齐，用一个word
33:52 隐式空闲列表的细节。结束块已分配大小为0
36:46 找到空闲块。第一次找代码。之后找从离开的地方找。找最佳匹配，扫描所有，速度较慢，但提高了效率。
39:30 分割空闲块
42:34 如何释放一个块。清除已分配的标志就可以，不过会造成外部碎片，得到两个连续的空闲块。
43:57 合并空闲块，释放的时候检查前后是否也是空闲块。找前面的块要重头遍历，搜索时间太长
46:13 解决方法：Knuth提出的边界标记技术，把块的头部复制到脚部，找上一个的脚部就能根据大小找到头部
49:55 合并时的4种情况
52:41 边界标记的缺点，它们是内部碎片。优化方法：已分配的块不需要脚部，怎样知道前面块是已分配的？把编码的 已分配/空闲 位放在当前块多出来的低位里。妙啊！
59:38 总结关键策略。放置策略，不错的适配接近最佳适配。分割策略，处理剩下的部分。合并策略，每次free合并还是扫描合并
64:37 隐式列表总结。简单的分配器，各种属性。做shell lab

# Lecture20 动态内存分配 高级概念

00:16 上节课讲的峰值内存利用率
07:42 追踪空闲块，方法2：显式空闲列表，双向链表，分离的空闲列表。长时间问答环节
22:24 分离的显式空闲列表，分离和释放
23:30 释放，LIFO策略后进先出，新释放的插到链表开始处
24:30 保持按地址排序的块，释放的时候地址排序策略
28:10 LIFO
30:28 LIFO情况2，前驱空闲，合并
33:46 LIFO情况3，后继空闲，合并
35:21 LIFO情况4，前驱后继都空闲，合并
38:01 总结
39:03 追踪空闲块：方法3创建一个分离的空闲链表（seglist）。维护多个空闲链表，每个链表中的块大小大致相等（书上P604提到了根据2的幂来划分）
40:10 seglist分配器，分配大小为n的块，就去相应的空闲列表，分配第一块的全部; 如果列表为空，分配器调用sbrk分配内存。
42:12 seglist的优点
43:44 学生提问。空闲列表数组存放在堆的开头
46:05 隐式内存管理器，垃圾回收
51:02 将内存视为有向图，堆节点对应已分配块，有向边对应指针，根节点对应不在堆中的位置，包含指向堆的指针，比如寄存器里的指针，指向堆中的内存位置。不可达的堆节点就是垃圾
53:26 基于`malloc`和`free`的简单垃圾收集器Mark & Sweep垃圾收集器。一直`malloc`直到空间不足;头部加额外的标志位，从所有根节点遍历设置标志位，然后从堆的最开始扫描查找未标记的所有分配块，没标记的都是垃圾就可以释放掉了，并返回空闲列表
56:47 这个假设的简单实现。函数功能
57:47 标记步骤的伪代码，`mark`深度优先遍历，`sweep`
60:09 C语言做这些事，判断是否是指针的问题
62:03 涉及内存的错误
63:31 指针的错误，理解指针，运算符优先级
66:04 指针的测验题
72:45 常见错误，`scanf`错误
73:07 读取未初始化的内存，`malloc`不会初始化为0
73:46 分配可能错误大小的对象，错误把指针的指针当指针用
74:55 覆盖内存错误
75:22 没检查大小，attack lab缓冲区溢出
75:36 误解指针算数，增加指针的大小实际增加`sizeof()`，所以+=1就好
76:40 错误地引用指针
78:32 忘记局部变量消失，返回局部变量的地址
78:59 多次释放一个块
79:19 引用被free过的块
79:33 内存泄漏没释放变成垃圾
79:50 GDB，检查复杂的数据结构，一致性检查

# Lecture 21 网络编程 第1部分

01:37 客户端-服务器模型。电话既是客户端也是服务器
03:49 网络主机的硬件组成
05:23 计算机网络的基础概念。internet的i大写特指最大的因特网，小写指的是互联网这一概念
08:00 低层级网络。以太网，几个主机通过（通常是）双绞线连到集线器。每个以太网适配器有唯一的48位MAC地址。主机发送帧到这个网段内其它主机。
10:00 下一级。网桥
10:42 局域网的概念视图。
10:49 下一级。小型互联网络。三台路由器连接起两个局域网和两个广域网
11:10 一个互联网络的逻辑结构
12:06 互联网协议的概念
12:43 互联网协议干啥。命名规则，可靠的传递机制
14:00 把报文从主机A发送到主机B，附上有路由信息的包头，
16:15 因特网。IP协议，定义了命名主机的方法，发送包（数据报）的方法，尽力
17:44 UDP，不可靠
18:07 TCP，99%的流量通过它，可靠。接受发送的所有数据，分割成单独的数据包，没送到重复发送。按正确顺序重新排列
19:50 软件系统观察，用户态核心态，socket编程
20:44 IPV4，32位地址，4个0-255的十进制，按照网络字节序被传递和存储，大端字节顺序。128.2.开头都在CMU。ipv6 128位
24:18 从程序员的角度考虑。大部分机器都用小端序，网络用大端序。IP地址是32位无符号整数，放在`in_addr`里面；四个函数实现转换（书上P648）
26:53 IP地址32位无符号整型和点分十进制串的转换，两个函数（书上P648）
27:54 域名，分级命名系统。一级.com,.edu之类。二级amazon，cmu之类。三级cs，www之类
29:01 DNS，管理模块在最顶层，大机器集群
30:39 命令，`nslookup localhost`，`hostname`。访问主流网站返回多个地址，试下还有不同的，说明有多个服务器
37:04 TCP连接每一端是socket，包含IP地址和16位端口号，服务通过端口号区分，客户端的端口是动态临时端口
40:01 知名的端口和服务名字，echo，ssh，smtp，http
40:22 连接剖析，连接基于服务器上的知名端口和客户端主机上的临时端口
41:01 用端口区分服务。内核区分来到这台机器的不同连接，为连接启动需要的软件和进程。一个客户端也可能和一个服务器的不同端口通信，用到不同的连接不会相互干扰
42:10 socket编程，可以看成文件描述符
43:16 socket API，`sockaddr`，socket类型（tcp/ip/udp）和地址。
44:25 `sockaddr_in`, 用于ipv4，AF_INEF，大端序，后面填0。可以看成`sockaddr`的子类
45:56 客户端-服务器系统的完整流程，5步，1启动服务端，1启动客户端，3会话通信，4客户端断开连接，5服务器断开连接
48:44 分模块讲。`getaddrinfo`用于查找从域名到IP地址的映射。客户端和服务器要做的第一步都是通过调用`socket`函数来创建连接
49:40 `socket`函数就是创建一个socket，三个参数，AF_INEF是一个32位IPV4地址，SOCK_STREAM表示是TCP连接。
51:45 服务端的`bind`函数。
55:30 服务端`listen`函数
56:34 服务端`accept`函数
58:02 客户端`connect`函数
60:09 讲讲不同的端口以及创建连接时它们在做什么。服务器bind和listen创建监听端口，监听是否有连接。客户端调用socket创建文件描述符，并发出连接请求，连接请求通过网络传输到达服务器，内核把它交给运行在特定端口的程序由accept函数处理，accept函数返回一个新的文件描述符，服务器把它作为一个到特定客户端连接点，这么做是为了可以与多个客户端通信
62:30 真实的通信过程是读写操作来接受和发送信息。客户端完成通信会发送一个请求，服务器会读取文件，看到EOF，它明白这个特定的连接结束了，就会关闭连接。后面会讲多线程
64:33 `getaddrinfo`新函数，同时适用ipv4和v6,多线程更好工作
66:06 它的参数。。`addrinfo`数据结构
67:13 `freeaddrinfo`函数，释放返回的数据结构的空间。`gai_strerror`函数解释这个程序的返回值中各种错误代码的含义
67:46 返回的`result`是最后一个参数，是指向`addrinfo`的链表。例子twitter
69:40 `addrinfo`，成员
70:49 `getnameinfo`函数
71:20 转换的例子。当作nslookup的简易版
75:15 localhost 127.0.0.1 指的是自己的机器，把自己的机器既当服务端也当客户端调试

# Lecture 22 网络编程 第2部分

01:30 `hostinfo`程序
04:35 回顾上次的概述图，单个连接的服务器，`getaddrinfo`
07:56 `sockaddr`，`sockaddr_in`结构
10:03 `getaddrinfo`，`freeaddrinfo`，`gai_strerror`
12:54 `getaddrinfo`返回的`addrinfo`数据结构
13:58 `getnameinfo`功能
15:12 `hostinfo`程序
20:32 回到概述图，`socket`是本地调用，为此连接分配一些数据结构。`connect`就像拨打电话
21:58 辅助函数，`open_clientfd`，
28:36 `open_listenfd`
35:45 例子echo，一个客户端
40:17 实现，客户端代码
42:19 服务端代码
46:43 telnet
48:21 http
50:56 静态内容html 动态内容
51:58 URL
52:57 HTTP请求
53:31 HTTP回应
54:06 演示
57:38 书上tiny代码建议看下
59:40 serve_static
63:55 动态内容
67:35 fork/exec
68:33 CGI，通用网关接口
69:44 创建环境变量，查询字符串
70:54 动态内容GET
72:39 对两个整数求和的CGI程序
:
:
:
:
:
:
:
:
:
:
::
::
::
::
::
::
::
:

:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

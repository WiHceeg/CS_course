---
title: GAMES101《现代计算机图形学入门》观看笔记
description: 时间轴记录
#date: 2020-01-01
#updated: 2020-01-01
categories:
- 图形学
tags:
- 图形学
---



# Lecture 01 Overview of Computer Graphics

01:22 什么是图形学，合成和操作视觉信息
01:34 只狼画面好，怎么判断，从技术上画面足够亮，全局光照
03:08 无主之地3，卡通
03:55 黑客帝国，特效是图形学应用
06:00 阿凡达，面部动作捕捉
07:00 动画疯狂动物城，毛发。几何，渲染
08:27 冰雪奇缘2, 烟雾，粒子。模拟
09:37 设计。CAD，车，光照。碰撞检测模拟
12:26 宜家网站。渲染
13:45 可视化 
15:15 虚拟现实，增强(augmented)现实，混合现实
18:06 电子绘画
19:53 模拟。尘埃，黑洞
21:56 Graphical User Interfaces
22:43 Typography 字体
24:32 为什么学图形学。基本智力挑战：创建逼真的虚拟世界与之互动; 需要了解真实的物理世界; 新的计算方法，显式，技术
25:58 技术挑战：数学，光学，3D形体，动画，模拟
26:43 学图形学的理由awesome
27:50 主要4部分，光栅化，几何（曲线曲面），光线追踪，动画与模拟
29:10 光栅化：把几何图元投影到屏幕。30fps表示实时，不到就算离线。
30:07 几何，曲线曲面
30:34 光线追踪，动画和电影，真实。trade off，实时光线追踪
31:46 动画模拟。球弹，仿真布垂下来。
32:31 这门课不讲Opengl / DirectX / Vulcan，不讲Shaders，不讲三维建模，不讲计算机视觉（一切需要猜测的内容就是计算机视觉在做的事情），不讲深度学习
37:02 图形学和计算机视觉的区别
42:33 课程细节，网站，参考资料，答疑平台
46:23 作业，提交。大作业
52:11 用IDE
57:20 学术诚信

# Lecture 02 Review of Linear Algebra 

02:30 复习上节课内容
03:20 线性代数
03:39 图形学依赖于数学，物理，信号处理，数字分析，美学
05:50 这节课讲的线性代数，向量，矩阵
06:41 蜗牛动画旋转例子
07:41 向量，向量长度，单位向量，向量求和
13:25 迪卡尔坐标系
16:20 向量的乘法，点乘可以得到夹角， 交换率分配率结合率。点乘的另一个作用，一个向量投影到另一个向量上，可以把一个向量分解为两个垂直的向量。计算两个向量方向有多接近。
30:20 向量的叉积，交换率不存在，要变成负的。叉乘变成矩阵。在图形学中的作用，判断左右，判断内外（和顺时针或逆时针的边叉乘方向一样）做三角形光栅化的基础
43:05 向量叉乘定义坐标系，分解任意一个向量
44:53 矩阵，基本操作。乘法没交换率。转置，逆
53:42 向量的点乘和叉乘写成矩阵。叉乘的dual matrix
55:28 例子，Sponza场景，相机运动
58:38 作业0, 配环境。

# Lecture 03 Transformation

01:00 复习上节课，这节课的内容
02:48 模型变换（modeling），视图变换（viewing）
03:10 模型变换的例子，相机运动，机器人，机器人逆运动学，pixar
05:15 投影
06:45 缩放变换
10:20 反射(reflection)矩阵
11:40 剪切(shear)矩阵
16:10 旋转矩阵，推导
23:58 线性变换
25:58 齐次坐标，平移
32:58 点后面加1, 向量后面加0
40:00 仿射变换
44:00 逆变换
45:26 变换的组合。旋转默认是以原点为中心逆时针旋转。
48:21 不满足交换率，顺序
52:03 矩阵结合率
51:00 变换的分解，想绕点c旋转，先移-c，旋转，再移回去
57:55 三维变换，类比


# Lecture 04 Transformation Cont.

01:20 旋转负角度，转置，正交矩阵
05:25 今天要讲的内容，3维变换。观测变换分为视图（view/camera）变换和投影变换。3维的齐次坐标，4 × 4的矩阵
08:34 三维的缩放，平移，旋转（y是反的，因为是z×x）。
12:49 复杂旋转，欧拉角。俯仰，偏航，翻转。
15:30 Rodrigues公式，绕过原点的某个轴旋转。如果不过原点，就先移到原点，旋转完再移回原点。四元数考虑到插值，这门课不提
21:23 视图变换，以拍照举例，把要拍的东西安排一个好地方（模型变换），找一个好角度放相机（视图变换），拍照（投影变换）
25:12 相机放在哪怎样定义：位置，朝向，相机上方的
26:53 如何进行视图变换？约定**相机放在原点，向上是Y，看向-Z**
29:28 把任意一个相机放到这个位置
30:28 写成矩阵形式，先平移，再旋转。怎样把相机位姿变换到原点，可以先求怎样从原点变换到现在的相机位姿，然后逆变换，因为是正交变换所以转置就行
38:41 投影，正交投影，透视投影，透视投影近大远小
43:00 正交投影，相机放在标准位置，把Z扔掉，全移到[-1, 1]，得到的就是正交投影
45:27 平行投影的操作，定义一个立方体。长方体映射到标准立方体，l,r,b,t,f,n, 变换矩阵
53:00 透视投影，齐次坐标×z，
61:49 相似三角形，推导透视投影


# Lecture 05 Rasterization 1(Triangles)

04:20 复习上节课，观测变换
06:02 下一步，光栅化
06:39 上一次透视投影转化成正交投影
09:05 相机的垂直可视角度（Field of View，fovY），长宽比，推出水平可视角度
11:05 垂直可视角度与t， n 宽高比的关系
14:10 MVP（模型、视图、投影）变换之后，画在屏幕上
14:49 屏幕是二维数组，Raster是德语的屏幕，把东西画在屏幕上就是光栅化。picture element就是pixel
17:59 屏幕的空间定义，作者定义左下角是（0，0），往右x，往上y
22:03 [-1, 1]^2^映射到[0, width]×[0, height], 视口变换
24:50 例子，少年pi老虎的多边形
25:36 现实中的绘制工具
26:26 光栅显示设备，示波器，用示波器画蘑菇
28:12 阴极射线管（CRT）显示器，隔行扫描（这一帧画奇数行，下一帧画偶数行）
32:35 现代显示设备，显存中的一块区域映射到屏幕上
34:00 平板显示设备，LCD，计算器显示器，手机显示器，视网膜屏，OLED
35:03 LCD就是液晶显示器，液晶通过自己的不同排布影响光的偏振方向，两个互相垂直的光栅，经过液晶的扭曲让光通过
37:08 LED就是发光二极管
37:55 电子墨水屏，kindle，墨水翻转，刷新率低
39:10 回到原来的话题
39:25 多边形变换到屏幕上，三角形
40:15 三角形的性质。最基础，多边形能拆成三角形；三角形一定是平面的，一定是凸的，定义三个顶点的属性，内部可以渐变（插值）
42:24 判断一个像素和三角形的关系
43:53 采样的方法，1维到3维
46:00 判断像素的中心是否在三角形内，inside(tri, x, y)函数，inside(tri, x + 0.5, y + 0.5)
48:47 回顾。函数的细节，向量的叉积判断是否在三角形内
52:51点碰巧在边界上，这门课不处理。可以自己定义，OpenGL, DX，认为落在上边和左边在三角形内，右边和下边不在。
54:18 把所有像素走一遍没必要，包围盒（最小x-最大x，最小y-最大y）
56:38 每一行找最左和最右，适用于光栅化旋转过的窄长三角形
58:12 实际的屏幕的光栅化，iPhone；三星拜耳阵列，绿色密度更高，因为人眼对绿色更敏感
61:09 彩色打印机，省墨的排列
62:03 这门课认为屏幕上每个像素是内部颜色均匀的方块
62:23 问题：像素是均匀的，锯齿，采样率不够会走样，下次讲反走样，抗锯齿。预告下节课比较难

# Lecture 06 Rasterization2 (Antialiasing and Z-Buffering)

01:20 今天的内容要难很多
02:30 上节课，光栅化关键的地方，像素中心，采样
03:23 这节课讲反走样，讲遮挡和可见性的问题，反走样
03:55 三角形，去锯齿的概念。锯齿的学名是走样
05:45 从理论开始说。照片的采样，视频的采样（不同的时间）
08:25 采样瑕疵（artifacts）
09:10 采样产生的artifacts例子，锯齿，摩尔纹，旋转（电风扇，车轮）（人眼的时间采样）
11:38 造成走样的本质，信号的变化太快，采样的速度跟不上
13:14 采样之前做模糊（滤波）
14:55 实际效果，对比
15:55 先采样再模糊，效果不行
16:49 为什么？
17:16 频域是啥？正弦和余弦。f = 1/T。
19:45 傅里叶级数展开
22:34  傅里叶变换，f(x) -> F(w)
24:43 从例子来看傅里叶变换，频率从低到高。采样间隔太大的后果
29:21 滤波的概念，把某个特定的频率段删掉
30:00 傅里叶变换，时域变到频域。图像的例子，中心定义成低频，周围定义成高频，通过亮度来表示有多少信息。自然图像低频在中间很少，高频在外面。为什么会有十字，因为要把不周期性重复的信号重复，图像的最上面最下面，最左边最右边会有剧烈的变化
33:27 把低频的抹掉再变回去，高通滤波（只剩下高频），只能看到一些边缘
36:10 只留下低频，边界看不到了。水波纹是啥
37:46 去掉高频和低频，就会提取到不太明显的边界
39:45 从另外一个角度，滤波 = 卷积（=平均）
40:38 卷积操作
43:18 卷积定理，时域卷积等于频域相乘
44:29 卷积定理例子，模糊
47:45 滤波器，1/9 3×3的卷积核
49:10 分析，越大的滤波核 = 越低的频率
51:27 采样：重复频率上的内容
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

# Lecture07 机器级编程(过程)

观看记录📝
Procedures

Stack Structure
Calling Conventions
Passing control
Passing data
Managing local data
Illustration of Recursion
2:45 ABI

3:50 Procedures的机制
7:34 X86-64Stack
ABI中调用的约定

14:38 过程中的控制
15:32 过程中的控制(例子)
21:43 过程中的数据(参数传递)
23:06 过程中的数据(例子)
26:19 过程中的局部变量管理
26:22 栈帧
31:15 一个具体的例子
34:42 X86-64/Linux栈帧的结构
39:06 Calling incr的例子
过程调用中寄存器的使用
46:29 Register保存的约定
49:38 不同寄存器的用途
51:17 被调用者保存寄存器的使用示例及其工作原理
递归部分的解释
54:31 递归的例子
1:03:40 递归部分的总结

# Lecture08 机器级编程(数据)

观看记录📝
数组
04:16 数组声明
05:14 数组访问
14:38 数组的例子
21:49 数组和指针的不同(C语言部分，可看书)
39:47 嵌套数组
45:32 嵌套数组的访问
51:04 多层数组的元素访问
54:58 N*N的矩阵
56:41 16*16数组访问的例子
结构
59:24 结构体的表示
1:00:16 指向结构体成员的指针
1:05:34 结构体和对齐的概念
1:07:03 对齐的原则
1:11:15 节省内存
浮点数
1:13:00 浮点数的历史
1:14:44 SSE3编程
1:16:01 Scalar和SIMD(真的好感动，实习时用过)
1:17:13 FP运算的知识
其实这里应该提及多个浮点数一起运算的加速效果

# Lecture09 机器级编程(高级专题)

观看记录📝
内存布局
2:14 最大寻址大小的解释(47位)（limit）
10:30 内存布局的解释(stack,heap,data,text/shared lib)
12:07 内存分配的例子
缓冲区溢出
17:54 缓冲区问题介绍
19:39 String库的缓冲区例子-gets,strcpy,strcat
23:26 缓冲区问题例子
32:15 缓冲区问题(缓存区溢出攻击例子)
33:31 代码注入攻击解释(很有意思)
36:47 当你替换代码是，如何确定注入的代码提供了准确的地址
38:09 Buffer overflows的历史
42:30 蠕虫和病毒的区别
43:09 避免缓冲区攻击的手段
43:24 避免程序中的缓冲区溢出
45:28 系统级别的防御:ASLR,权限，canary(啊啊啊啊啊,canary我遇到过)
1:03:51 关于这三种手段的老师的评价
1:10:59 attack lab讲解
1:12:59 联合体
1:13:40 联合体内存分布
1:15:40 字节顺序的问题

# Lecture10 程序优化

观看记录📝
01:10 整体的程序优化手段介绍
03:08 性能的两条人间真实:常数因子也很重要;必须了解系统知识才能优化性能
04:32 关于Compiler(编译器)的一些介绍
06:32 代码移动(Code Move)，先计算需要计算的值，然后在之后一直使用这个值
08:45 计算量减少(Reduction in Strength),将乘法转化为加法
10:07 共享通用表达(Share Common SubExpressions),通过抽取子表达式，将其提前转化为共享变量的方式减少计算量
13:00 优化中的障碍
13:10 障碍1，过程调用
18:08 为什么编译器无法优化这种过程调用错误,变量在变化，无法确定函数体内容
21:02 障碍2，内存别名导致，重复对内存地址进行读取的问题;
22:57 障碍2是由于内存别名的存在，导致程序无法确定两个内存是否完全无关，所以需要重复读取;
32:11 无序执行(乱序执行)，利用指令级别的并行
32:32 程序加速的例子
35:13 CPE指标的引入
38:30 程序加速，改进例子的极少
40:35 指令级并行的基本思想
44:26 超标量计算机简介
45:03 流水线技术，及其如何将计算分解为一系列不同的阶段
48:40 HasWell，不同阶段对应的时钟周期
51:00 计算机中，顺序依赖概念的解释
51:30 循环展开，对性能提高的效果展示
52:50 循环展开对于不同运算的性能提高效果
53:29 运算顺序改变，对于不同运算的性能提升效果
61:20 Avx2指令加速
66:46 条件预测，提前加载指令进行加速
72:30 获得高性能程序的一些关键点

# Lecture11 The Memory Hierarchy

02:45 SRAM和DRAM对比
04:50 Nonvalatile Memories(非易失性存储器)ROM，PROM，EPROM，EEPROM
07:17 bus总线，连接cpu芯片和主存
09:06 movq指令在总线上运行过程
12:05 机械硬盘结构
13:32 盘片，磁道，扇区
14:15 主轴多个盘片对齐
14:40 磁盘容量
15:40 磁盘容量影响因素 记录密度，磁道密度，面密度
16:20 面密度以前里外一样，现在不一样
18:10 计算磁盘容量
18:35 磁盘操作，旋转，磁臂移动
20:33 磁盘读操作
21:35 访问时间，寻道时间，旋转时间（平均是一圈的一半），传送时间
23:32 用真正的数字计算
25:33 逻辑磁盘 备用柱面
27:00 IO总线，现代PCI总线
29:18 CPU访问磁盘发生的步骤
30:00 DMA（直接内存访问）传送，磁盘传到内存不经过CPU
31:57 固态硬盘 闪存翻译层 块 页
35:05 性能特点 读写速度，顺序读写，随机读写
36:48 与旋转磁盘对比，用途
37:40 85～15年磁盘，DRAM，CPU速度发展
39:15 03年时钟频率很难加了，intel出了800w的CPU
41:00 CPU开始增加内核，05年出现双核
44:10 局部性：弥合CPU和内存之间差距的关键
45:27 时间局部性和空间局部性
46:10 例子
49:00 另一个例子，双重循环a[i][j]
52:56 三重循环应该怎么放顺序
55:08 存储器层次结构 L0～L6
58:15 Caches（缓存），举了个例子，去上学，书包就是家里屋子的缓存
1:01:49 缓存一般的工作方式(下节课讲细节)，内存分块
1:04:03 复制整个块
1:05:25 缓存命中
1:05:57 缓存不命中，CPU等待高速缓存从内存中取出块
1:06:35 不命中的种类。冷不命中也叫强制不命中，缓存是空的。
1:07:23 容量不命中，因为缓存大小有限，如果要用到比高速缓存大的数据，块就不够用了，工作集的概念
1:09:60 冲突未命中。缓存的实现方式，最简单的模型就是第i块只能放在(i mod 缓存大小_单位为块)处，要用到mod相同的就容易覆盖
1:11:37 各层各种形式缓存详细表格(书上P425)。依次是Register, TLB(翻译后备缓存), L1, L2, Virtual Memory, Buffer cache, Disk cache, Network buffer cache，Brower cache, Web cache

# Lecture12 Cache Memory

观看记录📝
01:09 内存的层级结构
01:54 Cache的概念
04:42 Cache的组织结构
07:30 Cache读
07:30 Cache的寻址方式
10:38 Direct Mapped Cache(E = 1)
20:58 E-way Set Associative Cache(E = 2)
35:38 Cache写
write hit
36:11 wrtie through and write back(脏位)
write miss
37:47 write-allocate and No-write-allocate
39:40 英特尔i7的cache架构
42:42 Cache性能的度量:MIss Rate, Hit Time, Miss Penalty
44:53 关于Cache数量度量的例子
46:58 写出缓存友好的代码
50:57 Memory Mountain
53:48 Memory Mountain Test代码
56:30 Memory Mountain可视化代码
59:14 Ridges of temporal locality时间局部性的山脊
1:03:53 重新排列循环
1:04:01 Matrix Multiplication例子
1:05:13 Miss Rate分析
1:08:05 Matrix Multiplication的总结
1:10:31 分块技术
1:14:41 分块技术的Cache Miss分析
1:16:14 Blocking的效果分析

# Lecture13 链接

观看记录📝
01:51 静态链接的过程
03:40 为什么要用链接：模块化，效率(编译)
05:20 连接器的作用
05:25 符号解析
07:20 重定位
09:20 三种目标文件的分类
09:25 .o可重定位目标模块
09:50 .out可执行文件
10:15 ,so共享目标文件
10:32 目标模块ELF标准
10:58 目标文件的格式:header,segment header table, .text section, .rodata section,.data section,.bss section, .symtab section, .rel .txt section,.rel .data section,.debug section, section header
15:13 链接器的符号分类，global symbols, external symbols, local symbols
19:30 局部非静态变量 vs 局部静态变量
21:30 链接器如何解决重复符号定义问题？强符号，弱符号;
32:04 避免全局变量的原因
36:00 重定位入口
44:15 加载可执行的目标文件
48:30 打包常用的函数
51:06 静态链接库
55:51 静态库链接的过程
56:13 使用静态库的过程
60:02 共享链接库
62:52 动态链接的加载过程
67:17 运行时的动态链接

杂项
53:13 常用库

示例
24:12 链接错误示例
sum
01:04 C程序示例
18:34 符号解析的过程
32:49 重定位的过程
41:26 重定位后的text部分
案例学习
70:24 库打桩

# Lecture14 异常控制流 异常和进程

02:41 异常控制流会在什么地方存在
05:04 异常的定义，三种情况
07:15 异常表
07:46 异常的分类方法，同步异步。异步异常，中断。
10:20 同步异常，陷阱和系统调用
10:54 故障，页缺失，保护故障
13:03 终止
13:33 Linux/x86-64 常用的系统调用
14:01 syscall，open 
15:54 故障的例子，页缺失，从磁盘到内存
16:58 故障的例子，无效内存引用
18:22 进程的定义
19:14 进程的两个抽象。第一个，独占cpu和寄存器。第二个，拥有自己的地址空间
21:02 top指令看进程
21:27 多进程管理共享，上下文切换是地址空间和寄存器的变化
23:40 逻辑控制流
24:50 并发
26:34 上下文切换的过程，用户模式和内核模式
28:19 系统调用错误处理
30:55 错误报告功能，unix_error
31:38 错误处理包装函数，Fork
32:43 进程控制函数，getpid，getppid
33:11 进程的三种状态，运行，停止，终止
34:18 终止进程，exit
35:33 fork创建子进程，返回两次
37:30 fork的例子
40:03 进程图，捕捉调用fork时发生的情况。顶点是语句的执行，边对应变量
41:30 进程图例子
44:10 多个连续fork例子
48:15 回收子进程
49:00 僵尸进程
49:35 系统安排init进程回收孤儿进程
51:00 一个僵尸现象的例子
52:41 另一个例子，父进程结束子进程没结束
54:14 wait用来与子进程同步并回收它们
55:18 wait工作原理的简单示例
57:35 复杂的例子，waitpid函数
59:59 execve运行不同的程序
1:03:10 新程序开始时的栈帧结构
1:05:56 execve的例子，用途
1:10:37 总结。异常，进程，fork，exit，wait，waitpid，execve

# Lecture15 信号和非本地跳转

00:52 linux进程体系，init创建守护进程Daemon，login shell
02:40 shell，bash
03:16 一个简单shell的main例程
04:17 eval求值
08:45 简单shell例程的问题，内存泄漏
08:55 异常控制流解决问题
09:29 信号的定义，Linux常见信号
13:20 信号的概念：发送信号
15:08 信号的概念：接受信号。三种反应
17:20 信号的概念：挂起和阻塞的信号
20:10 发送信号，进程组
21:44 kill的例子，kill -9,id前加横杠的意思
24:12 键盘发送信号，ctrl+c发送sigint，默认行为终止进程，ctrl+z发送sigtstp，默认行为挂起进程
24:55 ctrl+c和ctrl+z例子，ps命令，fg命令
26:10 系统调用kill发送信号
27:20 进程接受信号
28:33 pnb
30:02 信号的默认行为
30:24 使用signal函数的系统调用修改默认行为
32:25 安装处理程序的例子
33:59 信号处理程序看作并发流
38:00 信号处理程序被其它信号处理程序中断
39:01 阻塞和接触阻塞信号
40:10 用sigprocmasks函数阻塞和解除阻塞信号
42:13 安全的信号处理程序
44:32 编写安全程序的经验参考，6条经验
49:28 异步信号安全，Linux安全的系统级函数
53:08 作者开发的安全的I/O包
54:15 例子fork14
59:38 可移植信号处理，书上P541
63:10 作业列表的例子同步错误 书上P542
67:30 消除竞争的一种方法，书上P543
70:18 显式地等待信号
76:05 sigsuspend

# Lecture16 系统级I/O

02:25 这节课的主要内容
03:52 Unix文件，I/O设备，套接字
05:51 文件的另一种属性，文件位置
07:33 文件种类，今天讲普通文件，目录，套接字。
09:34 普通文件。文本文件换行，二进制文件
13:11 目录，层次结构，路径
14:22 打开文件，open函数，append从末尾打开，打开操作返回文件描述符,limit命令
18:00 返回值，系统调用时检查返回值。打开操作返回有符号返回值，负数表示打开失败
19:35 进程的三个文件描述符，标准输入输出错误，分别对应0 1 2
20:18 close函数关闭文件，遇到错误的情况
21:57 read函数读文件，还需要缓冲区指针和长度，返回0,正数，负数的情况
24:50 write写文件，参数和读类似，
25:48 Read，Write简单例子，这个例子系统级调用开销太大
29:00 演示，strace命令检测出程序运行时的系统调用
31:05 不足值的情况
35:20 作者写的RIO软件包，封装了低级I/O，自动处理不足值
38:13 rio_readn函数
40:47 带缓冲的I/O，rio_readinitb。 
43:20 读缓冲区的格式
44:04 用RIO函数边读边写的例子
46:06 文件元数据
47:06 stat查看文件系统的目录结构
48:42 文件信息如何在程序中表示
51:33 操作系统维护的与程序中文件相关的内部数据结构，考试难点
52:15 描述符表，打开文件表，vnode表
59:07 dup2函数复制描述符表项覆盖，用来做重定向
62:48 C语言标准I/O 带缓冲
65:12 3种I/O。设计RIO的原因，用于网络连接
66:27 每种I/O优缺点
68:53 推荐两本书
70:16 一个文件描述符的例子

# Lecture17 虚拟内存概念

00:21 一个物理寻址的系统
04:09 一个虚拟寻址的系统
05:23 地址空间。线性，虚拟，物理
06:40 为什么要实现虚拟内存，三个原因
09:04 虚拟内存作为缓存工具，磁盘上的虚拟页映射到DRAM中的物理页
11:40 DRAM缓存的组织结构
15:25 页表
17:30 页命中
19:20 处理缺页（DRAM缓存不命中）
20:53 分配页面，malloc函数调用sbrk函数
22:02 虚拟内存工作得很好，因为局部性
24:00 虚拟内存作为内存管理的工具，每个进程有独立的页表
29:18 简化链接和加载
32:49 虚拟内存作为保护内存的工具，48个有效位，高位都是1的地址是内核中的代码和数据，都是0的地址是给用户代码保留的。x86-64新出的EXEC位防止代码注入攻击
36:12 地址翻译 
37:36 使用页表进行地址转换的原理
41:59 地址翻译页面命中
43:01 地址翻译缺页
44:29 结合高速缓存和虚拟内存
48:03 利用MMU中关于PTE的小缓存TLB（翻译后备缓冲器）加速地址翻译
50:10 TLB命中，TLB不命中
51:34 多级页表
53:33 一个二级页表层次结构
55:30 使用k级页表的地址翻译，k个VPN
57:34 问答直到结束

# Lecture18 虚拟内存系统

00:19 简单的内存系统的例子，和书上P574一样
10:54 另一个例子
17:41 虚拟内存在Core i7/Linux下如何工作
24:58 Core i7端到端的地址翻译
28:48 Intel系统页表条目的结构，第一二三级
31:38 第四级页表条目格式
33:25 Core i7页表翻译
36:11 加速访问L1高速缓存
38:36 Liunx虚拟内存系统。内核产生的也是虚拟地址
44:12 Linux虚拟内存区域
46:38 缺页异常处理
50:53 内存映射 
53:40 再看共享对象
56:22 私有写时复制对象
60:49 fork函数，内核只拷贝所有内核数据结构，mm_struct, area_struct和页表。将两个进程的每个页面都标记为只读，每个区域结构都标记为私有写时复制
65:13 execve系统调用。删除当前进程的所有area_struct和页表，为新区域创建新的
71:34 mmap函数用户级内存映射
75:34 mmap的例子

# Lecture19 动态内存分配 基础概念

00:48 本周内容主题：储存器分配，其工作原理，如何使用它们管理虚拟内存
01:05 动态内存分配器，堆
01:56 块被分配和释放，显式分配器malloc和free，隐式分配器使用垃圾回收（Java等）
03:37 malloc，free，calloc初始化分配块为0,realloc调整之前malloc块的大小，sbrk增长和缩小堆
05:40 malloc例子
07:17 今天实现malloc和free等功能，简化假设，内存地址不按字节，按word，假设word是4个字节（int的大小）
08:38 malloc，free分配释放块的例子
10:02 分配器的要求和目标各种约束
12:24 速度和内存效率指标，吞吐量。在malloc和free序列最大化吞吐量和使内存利用率尽可能高
14:01 使内存利用率尽可能高，衡量使用堆的效率。有效载荷/堆的大小
17:24 碎片。内部碎片。
18:58 外部碎片。堆中有足够内存但没有足够大的空闲块
21:36 实现问题。free怎么知道块的大小？怎样追踪空闲块？如何处理剩余空间？如何选择空闲块？如何处理刚刚被释放的块？
23:09 知道要释放多少。块头部编码了块大小
24:15 追踪空闲块。隐式空闲列表，空闲块通过头部的隐含字段连接，分配器可以遍历。
29:00 构建隐式空闲列表。
31:51 需要块的大小和分配状态，不需要两个word，利用块需要边界对齐，用一个word
33:52 隐式空闲列表的细节。结束块已分配大小为0
36:46 找到空闲块。第一次找代码。之后找从离开的地方找。找最佳匹配，扫描所有，速度较慢，但提高了效率。
39:30 分割空闲块
42:34 如何释放一个块。清除已分配的标志就可以，不过会造成外部碎片，得到两个连续的空闲块。
43:57 合并空闲块，释放的时候检查前后是否也是空闲块。找前面的块要重头遍历，搜索时间太长
46:13 解决方法：Knuth提出的边界标记技术，把块的头部复制到脚部，找上一个的脚部就能根据大小找到头部
49:55 合并时的4种情况
52:41 边界标记的缺点，它们是内部碎片。优化方法：已分配的块不需要脚部，怎样知道前面块是已分配的？把编码的 已分配/空闲 位放在当前块多出来的低位里。妙啊！
59:38 总结关键策略。放置策略，不错的适配接近最佳适配。分割策略，处理剩下的部分。合并策略，每次free合并还是扫描合并
64:37 隐式列表总结。简单的分配器，各种属性。做shell lab

# Lecture20 动态内存分配 高级概念

00:16 上节课讲的峰值内存利用率
07:42 追踪空闲块，方法2：显式空闲列表，双向链表，分离的空闲列表。长时间问答环节
22:24 分离的显式空闲列表，分离和释放
23:30 释放，LIFO策略后进先出，新释放的插到链表开始处
24:30 保持按地址排序的块，释放的时候地址排序策略
28:10 LIFO
30:28 LIFO情况2，前驱空闲，合并
33:46 LIFO情况3，后继空闲，合并
35:21 LIFO情况4，前驱后继都空闲，合并
38:01 总结
39:03 追踪空闲块：方法3创建一个分离的空闲链表（seglist）。维护多个空闲链表，每个链表中的块大小大致相等（书上P604提到了根据2的幂来划分）
40:10 seglist分配器，分配大小为n的块，就去相应的空闲列表，分配第一块的全部; 如果列表为空，分配器调用sbrk分配内存。
42:12 seglist的优点
43:44 学生提问。空闲列表数组存放在堆的开头
46:05 隐式内存管理器，垃圾回收
51:02 将内存视为有向图，堆节点对应已分配块，有向边对应指针，根节点对应不在堆中的位置，包含指向堆的指针，比如寄存器里的指针，指向堆中的内存位置。不可达的堆节点就是垃圾
53:26 基于`malloc`和`free`的简单垃圾收集器Mark & Sweep垃圾收集器。一直`malloc`直到空间不足;头部加额外的标志位，从所有根节点遍历设置标志位，然后从堆的最开始扫描查找未标记的所有分配块，没标记的都是垃圾就可以释放掉了，并返回空闲列表
56:47 这个假设的简单实现。函数功能
57:47 标记步骤的伪代码，`mark`深度优先遍历，`sweep`
60:09 C语言做这些事，判断是否是指针的问题
62:03 涉及内存的错误
63:31 指针的错误，理解指针，运算符优先级
66:04 指针的测验题
72:45 常见错误，`scanf`错误
73:07 读取未初始化的内存，`malloc`不会初始化为0
73:46 分配可能错误大小的对象，错误把指针的指针当指针用
74:55 覆盖内存错误
75:22 没检查大小，attack lab缓冲区溢出
75:36 误解指针算数，增加指针的大小实际增加`sizeof()`，所以+=1就好
76:40 错误地引用指针
78:32 忘记局部变量消失，返回局部变量的地址
78:59 多次释放一个块
79:19 引用被free过的块
79:33 内存泄漏没释放变成垃圾
79:50 GDB，检查复杂的数据结构，一致性检查

# Lecture 21 网络编程 第1部分

01:37 客户端-服务器模型。电话既是客户端也是服务器
03:49 网络主机的硬件组成
05:23 计算机网络的基础概念。internet的i大写特指最大的因特网，小写指的是互联网这一概念
08:00 低层级网络。以太网，几个主机通过（通常是）双绞线连到集线器。每个以太网适配器有唯一的48位MAC地址。主机发送帧到这个网段内其它主机。
10:00 下一级。网桥
10:42 局域网的概念视图。
10:49 下一级。小型互联网络。三台路由器连接起两个局域网和两个广域网
11:10 一个互联网络的逻辑结构
12:06 互联网协议的概念
12:43 互联网协议干啥。命名规则，可靠的传递机制
14:00 把报文从主机A发送到主机B，附上有路由信息的包头，
16:15 因特网。IP协议，定义了命名主机的方法，发送包（数据报）的方法，尽力
17:44 UDP，不可靠
18:07 TCP，99%的流量通过它，可靠。接受发送的所有数据，分割成单独的数据包，没送到重复发送。按正确顺序重新排列
19:50 软件系统观察，用户态核心态，socket编程
20:44 IPV4，32位地址，4个0-255的十进制，按照网络字节序被传递和存储，大端字节顺序。128.2.开头都在CMU。ipv6 128位
24:18 从程序员的角度考虑。大部分机器都用小端序，网络用大端序。IP地址是32位无符号整数，放在`in_addr`里面；四个函数实现转换（书上P648）
26:53 IP地址32位无符号整型和点分十进制串的转换，两个函数（书上P648）
27:54 域名，分级命名系统。一级.com,.edu之类。二级amazon，cmu之类。三级cs，www之类
29:01 DNS，管理模块在最顶层，大机器集群
30:39 命令，`nslookup localhost`，`hostname`。访问主流网站返回多个地址，试下还有不同的，说明有多个服务器
37:04 TCP连接每一端是socket，包含IP地址和16位端口号，服务通过端口号区分，客户端的端口是动态临时端口
40:01 知名的端口和服务名字，echo，ssh，smtp，http
40:22 连接剖析，连接基于服务器上的知名端口和客户端主机上的临时端口
41:01 用端口区分服务。内核区分来到这台机器的不同连接，为连接启动需要的软件和进程。一个客户端也可能和一个服务器的不同端口通信，用到不同的连接不会相互干扰
42:10 socket编程，可以看成文件描述符
43:16 socket API，`sockaddr`，socket类型（tcp/ip/udp）和地址。
44:25 `sockaddr_in`, 用于ipv4，AF_INEF，大端序，后面填0。可以看成`sockaddr`的子类
45:56 客户端-服务器系统的完整流程，5步，1启动服务端，1启动客户端，3会话通信，4客户端断开连接，5服务器断开连接
48:44 分模块讲。`getaddrinfo`用于查找从域名到IP地址的映射。客户端和服务器要做的第一步都是通过调用`socket`函数来创建连接
49:40 `socket`函数就是创建一个socket，三个参数，AF_INEF是一个32位IPV4地址，SOCK_STREAM表示是TCP连接。
51:45 服务端的`bind`函数。
55:30 服务端`listen`函数
56:34 服务端`accept`函数
58:02 客户端`connect`函数
60:09 讲讲不同的端口以及创建连接时它们在做什么。服务器bind和listen创建监听端口，监听是否有连接。客户端调用socket创建文件描述符，并发出连接请求，连接请求通过网络传输到达服务器，内核把它交给运行在特定端口的程序由accept函数处理，accept函数返回一个新的文件描述符，服务器把它作为一个到特定客户端连接点，这么做是为了可以与多个客户端通信
62:30 真实的通信过程是读写操作来接受和发送信息。客户端完成通信会发送一个请求，服务器会读取文件，看到EOF，它明白这个特定的连接结束了，就会关闭连接。后面会讲多线程
64:33 `getaddrinfo`新函数，同时适用ipv4和v6,多线程更好工作
66:06 它的参数。。`addrinfo`数据结构
67:13 `freeaddrinfo`函数，释放返回的数据结构的空间。`gai_strerror`函数解释这个程序的返回值中各种错误代码的含义
67:46 返回的`result`是最后一个参数，是指向`addrinfo`的链表。例子twitter
69:40 `addrinfo`，成员
70:49 `getnameinfo`函数
71:20 转换的例子。当作nslookup的简易版
75:15 localhost 127.0.0.1 指的是自己的机器，把自己的机器既当服务端也当客户端调试

# Lecture 22 网络编程 第2部分

01:30 `hostinfo`程序
04:35 回顾上次的概述图，单个连接的服务器，`getaddrinfo`
07:56 `sockaddr`，`sockaddr_in`结构
10:03 `getaddrinfo`，`freeaddrinfo`，`gai_strerror`
12:54 `getaddrinfo`返回的`addrinfo`数据结构
13:58 `getnameinfo`功能
15:12 `hostinfo`程序
20:32 回到概述图，`socket`是本地调用，为此连接分配一些数据结构。`connect`就像拨打电话
21:58 辅助函数，`open_clientfd`，
28:36 `open_listenfd`
35:45 例子echo，一个客户端
40:17 实现，客户端代码
42:19 服务端代码
46:43 telnet
48:21 http
50:56 静态内容html 动态内容
51:58 URL
52:57 HTTP请求
53:31 HTTP回应
54:06 演示
57:38 书上tiny代码建议看下
59:40 serve_static
63:55 动态内容
67:35 fork/exec
68:33 CGI，通用网关接口
69:44 创建环境变量，查询字符串
70:54 动态内容GET
72:39 对两个整数求和的CGI程序
:
:
:
:
:
:
:
:
:
:
::
::
::
::
::
::
::
:

:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
: